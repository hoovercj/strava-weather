/**
 * Strava API v3
 * Strava API
 *
 * OpenAPI spec version: 3.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://www.strava.com/api/v3';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }

            if (!typeMap[type].getAttributeTypeMap) {
                return data; // Cannot get type map
            }

            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

/**
* A set of rolled-up statistics and totals for an athlete
*/
export class ActivityStats {
    /**
    * The longest distance ridden by the athlete.
    */
    'biggestRideDistance'?: number;
    /**
    * The highest climb ridden by the athlete.
    */
    'biggestClimbElevationGain'?: number;
    'recentRideTotals'?: ActivityTotal;
    'recentRunTotals'?: ActivityTotal;
    'recentSwimTotals'?: ActivityTotal;
    'ytdRideTotals'?: ActivityTotal;
    'ytdRunTotals'?: ActivityTotal;
    'ytdSwimTotals'?: ActivityTotal;
    'allRideTotals'?: ActivityTotal;
    'allRunTotals'?: ActivityTotal;
    'allSwimTotals'?: ActivityTotal;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "biggestRideDistance",
            "baseName": "biggest_ride_distance",
            "type": "number"
        },
        {
            "name": "biggestClimbElevationGain",
            "baseName": "biggest_climb_elevation_gain",
            "type": "number"
        },
        {
            "name": "recentRideTotals",
            "baseName": "recent_ride_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "recentRunTotals",
            "baseName": "recent_run_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "recentSwimTotals",
            "baseName": "recent_swim_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "ytdRideTotals",
            "baseName": "ytd_ride_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "ytdRunTotals",
            "baseName": "ytd_run_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "ytdSwimTotals",
            "baseName": "ytd_swim_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "allRideTotals",
            "baseName": "all_ride_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "allRunTotals",
            "baseName": "all_run_totals",
            "type": "ActivityTotal"
        },
        {
            "name": "allSwimTotals",
            "baseName": "all_swim_totals",
            "type": "ActivityTotal"
        }    ];

    static getAttributeTypeMap() {
        return ActivityStats.attributeTypeMap;
    }
}

/**
* A roll-up of metrics pertaining to a set of activities.
*/
export class ActivityTotal {
    /**
    * The number of activities considered in this total.
    */
    'count'?: number;
    /**
    * The total distance covered by the considered activities.
    */
    'distance'?: number;
    /**
    * The total moving time of the considered activities.
    */
    'movingTime'?: number;
    /**
    * The total elapsed time of the considered activities.
    */
    'elapsedTime'?: number;
    /**
    * The total elevation gain of the considered activities.
    */
    'elevationGain'?: number;
    /**
    * The total number of achievements of the considered activities.
    */
    'achievementCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "movingTime",
            "baseName": "moving_time",
            "type": "number"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "elevationGain",
            "baseName": "elevation_gain",
            "type": "number"
        },
        {
            "name": "achievementCount",
            "baseName": "achievement_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ActivityTotal.attributeTypeMap;
    }
}

/**
* An enumeration of the types an activity may have.
*/
export class ActivityType {

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return ActivityType.attributeTypeMap;
    }
}

export class ActivityZone {
    'score'?: number;
    'distributionBuckets'?: TimedZoneDistribution;
    'type'?: ActivityZone.TypeEnum;
    'sensorBased'?: boolean;
    'points'?: number;
    'customZones'?: boolean;
    'max'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "distributionBuckets",
            "baseName": "distribution_buckets",
            "type": "TimedZoneDistribution"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ActivityZone.TypeEnum"
        },
        {
            "name": "sensorBased",
            "baseName": "sensor_based",
            "type": "boolean"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "number"
        },
        {
            "name": "customZones",
            "baseName": "custom_zones",
            "type": "boolean"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ActivityZone.attributeTypeMap;
    }
}

export namespace ActivityZone {
    export enum TypeEnum {
        Heartrate = <any> 'heartrate',
        Power = <any> 'power'
    }
}
export class BaseStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: BaseStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: BaseStream.SeriesTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "BaseStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "BaseStream.SeriesTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return BaseStream.attributeTypeMap;
    }
}

export namespace BaseStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class Comment {
    /**
    * The unique identifier of this comment
    */
    'id'?: number;
    /**
    * The identifier of the activity this comment is related to
    */
    'activityId'?: number;
    /**
    * The content of the comment
    */
    'text'?: string;
    'athlete'?: SummaryAthlete;
    /**
    * The time at which this comment was created.
    */
    'createdAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "activityId",
            "baseName": "activity_id",
            "type": "number"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        },
        {
            "name": "athlete",
            "baseName": "athlete",
            "type": "SummaryAthlete"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Comment.attributeTypeMap;
    }
}

export class ExplorerResponse {
    /**
    * The set of segments matching an explorer request
    */
    'segments'?: Array<ExplorerSegment>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "segments",
            "baseName": "segments",
            "type": "Array<ExplorerSegment>"
        }    ];

    static getAttributeTypeMap() {
        return ExplorerResponse.attributeTypeMap;
    }
}

export class ExplorerSegment {
    /**
    * The unique identifier of this segment
    */
    'id'?: number;
    /**
    * The name of this segment
    */
    'name'?: string;
    /**
    * The category of the climb
    */
    'climbCategory'?: number;
    /**
    * The description for the category of the climb
    */
    'climbCategoryDesc'?: ExplorerSegment.ClimbCategoryDescEnum;
    /**
    * The segment's average grade, in percents
    */
    'avgGrade'?: number;
    'startLatlng'?: LatLng;
    'endLatlng'?: LatLng;
    /**
    * The segments's evelation difference, in meters
    */
    'elevDifference'?: number;
    /**
    * The segment's distance, in meters
    */
    'distance'?: number;
    /**
    * The polyline of the segment
    */
    'points'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "climbCategory",
            "baseName": "climb_category",
            "type": "number"
        },
        {
            "name": "climbCategoryDesc",
            "baseName": "climb_category_desc",
            "type": "ExplorerSegment.ClimbCategoryDescEnum"
        },
        {
            "name": "avgGrade",
            "baseName": "avg_grade",
            "type": "number"
        },
        {
            "name": "startLatlng",
            "baseName": "start_latlng",
            "type": "LatLng"
        },
        {
            "name": "endLatlng",
            "baseName": "end_latlng",
            "type": "LatLng"
        },
        {
            "name": "elevDifference",
            "baseName": "elev_difference",
            "type": "number"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "points",
            "baseName": "points",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExplorerSegment.attributeTypeMap;
    }
}

export namespace ExplorerSegment {
    export enum ClimbCategoryDescEnum {
        NC = <any> 'NC',
        _4 = <any> '4',
        _3 = <any> '3',
        _2 = <any> '2',
        _1 = <any> '1',
        HC = <any> 'HC'
    }
}
/**
* Encapsulates the errors that may be returned from the API.
*/
export class Fault {
    /**
    * The set of specific errors associated with this fault, if any.
    */
    'errors'?: Array<Error>;
    /**
    * The message of the fault.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<Error>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Fault.attributeTypeMap;
    }
}

export class HeartRateZoneRanges {
    /**
    * Whether the athlete has set their own custom heart rate zones
    */
    'customZones'?: boolean;
    'zones'?: ZoneRanges;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customZones",
            "baseName": "custom_zones",
            "type": "boolean"
        },
        {
            "name": "zones",
            "baseName": "zones",
            "type": "ZoneRanges"
        }    ];

    static getAttributeTypeMap() {
        return HeartRateZoneRanges.attributeTypeMap;
    }
}

export class Lap {
    /**
    * The unique identifier of this lap
    */
    'id'?: number;
    'activity'?: MetaActivity;
    'athlete'?: MetaAthlete;
    /**
    * The lap's average cadence
    */
    'averageCadence'?: number;
    /**
    * The lap's average speed
    */
    'averageSpeed'?: number;
    /**
    * The lap's distance, in meters
    */
    'distance'?: number;
    /**
    * The lap's elapsed time, in seconds
    */
    'elapsedTime'?: number;
    /**
    * The start index of this effort in its activity's stream
    */
    'startIndex'?: number;
    /**
    * The end index of this effort in its activity's stream
    */
    'endIndex'?: number;
    /**
    * The index of this lap in the activity it belongs to
    */
    'lapIndex'?: number;
    /**
    * The maximum speed of this lat, in meters per second
    */
    'maxSpeed'?: number;
    /**
    * The lap's moving time, in seconds
    */
    'movingTime'?: number;
    /**
    * The name of the lap
    */
    'name'?: string;
    /**
    * The athlete's pace zone during this lap
    */
    'paceZone'?: number;
    'split'?: number;
    /**
    * The time at which the lap was started.
    */
    'startDate'?: Date;
    /**
    * The time at which the lap was started in the local timezone.
    */
    'startDateLocal'?: Date;
    /**
    * The elevation gain of this lap, in meters
    */
    'totalElevationGain'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "activity",
            "baseName": "activity",
            "type": "MetaActivity"
        },
        {
            "name": "athlete",
            "baseName": "athlete",
            "type": "MetaAthlete"
        },
        {
            "name": "averageCadence",
            "baseName": "average_cadence",
            "type": "number"
        },
        {
            "name": "averageSpeed",
            "baseName": "average_speed",
            "type": "number"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "startIndex",
            "baseName": "start_index",
            "type": "number"
        },
        {
            "name": "endIndex",
            "baseName": "end_index",
            "type": "number"
        },
        {
            "name": "lapIndex",
            "baseName": "lap_index",
            "type": "number"
        },
        {
            "name": "maxSpeed",
            "baseName": "max_speed",
            "type": "number"
        },
        {
            "name": "movingTime",
            "baseName": "moving_time",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "paceZone",
            "baseName": "pace_zone",
            "type": "number"
        },
        {
            "name": "split",
            "baseName": "split",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "startDateLocal",
            "baseName": "start_date_local",
            "type": "Date"
        },
        {
            "name": "totalElevationGain",
            "baseName": "total_elevation_gain",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Lap.attributeTypeMap;
    }
}

/**
* A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
*/
export class LatLng extends Array<number> {

    static discriminator: string | undefined = undefined;

}

export class MembershipApplication {
    /**
    * Whether the application for membership was successfully submitted
    */
    'success'?: boolean;
    /**
    * Whether the membership is currently active
    */
    'active'?: boolean;
    /**
    * The membership status of this application
    */
    'membership'?: MembershipApplication.MembershipEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        },
        {
            "name": "membership",
            "baseName": "membership",
            "type": "MembershipApplication.MembershipEnum"
        }    ];

    static getAttributeTypeMap() {
        return MembershipApplication.attributeTypeMap;
    }
}

export namespace MembershipApplication {
    export enum MembershipEnum {
        Member = <any> 'member',
        Pending = <any> 'pending'
    }
}
export class MetaActivity {
    /**
    * The unique identifier of the activity
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MetaActivity.attributeTypeMap;
    }
}

export class MetaAthlete {
    /**
    * The unique identifier of the athlete
    */
    'id'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return MetaAthlete.attributeTypeMap;
    }
}

export class MetaClub {
    /**
    * The club's unique identifier.
    */
    'id'?: number;
    /**
    * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
    */
    'resourceState'?: number;
    /**
    * The club's name.
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "resourceState",
            "baseName": "resource_state",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MetaClub.attributeTypeMap;
    }
}

export class ModelError {
    /**
    * The code associated with this error.
    */
    'code'?: string;
    /**
    * The specific field or aspect of the resource associated with this error.
    */
    'field'?: string;
    /**
    * The type of resource associated with this error.
    */
    'resource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "resource",
            "baseName": "resource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModelError.attributeTypeMap;
    }
}

export class PhotosSummary {
    /**
    * The number of photos
    */
    'count'?: number;
    'primary'?: PhotosSummaryPrimary;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "primary",
            "baseName": "primary",
            "type": "PhotosSummaryPrimary"
        }    ];

    static getAttributeTypeMap() {
        return PhotosSummary.attributeTypeMap;
    }
}

export class PhotosSummaryPrimary {
    'id'?: number;
    'source'?: number;
    'uniqueId'?: string;
    'urls'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "number"
        },
        {
            "name": "uniqueId",
            "baseName": "unique_id",
            "type": "string"
        },
        {
            "name": "urls",
            "baseName": "urls",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return PhotosSummaryPrimary.attributeTypeMap;
    }
}

export class PolylineMap {
    /**
    * The identifier of the map
    */
    'id'?: string;
    /**
    * The polyline of the map
    */
    'polyline'?: string;
    /**
    * The summary polyline of the map
    */
    'summaryPolyline'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "polyline",
            "baseName": "polyline",
            "type": "string"
        },
        {
            "name": "summaryPolyline",
            "baseName": "summary_polyline",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PolylineMap.attributeTypeMap;
    }
}

export class PowerZoneRanges {
    'zones'?: ZoneRanges;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "zones",
            "baseName": "zones",
            "type": "ZoneRanges"
        }    ];

    static getAttributeTypeMap() {
        return PowerZoneRanges.attributeTypeMap;
    }
}

export class Route {
    'athlete'?: SummaryAthlete;
    /**
    * The description of the route
    */
    'description'?: string;
    /**
    * The route's distance, in meters
    */
    'distance'?: number;
    /**
    * The route's elevation gain.
    */
    'elevationGain'?: number;
    /**
    * The unique identifier of this route
    */
    'id'?: number;
    'map'?: PolylineMap;
    /**
    * The name of this route
    */
    'name'?: string;
    /**
    * Whether this route is private
    */
    '_private'?: boolean;
    /**
    * Whether this route is starred by the logged-in athlete
    */
    'starred'?: boolean;
    'timestamp'?: number;
    /**
    * This route's type (1 for ride, 2 for runs)
    */
    'type'?: number;
    /**
    * This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
    */
    'subType'?: number;
    /**
    * The segments traversed by this route
    */
    'segments'?: Array<SummarySegment>;
    /**
    * The directions of this route
    */
    'directions'?: Array<RouteDirection>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "athlete",
            "baseName": "athlete",
            "type": "SummaryAthlete"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "elevationGain",
            "baseName": "elevation_gain",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "PolylineMap"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "starred",
            "baseName": "starred",
            "type": "boolean"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "number"
        },
        {
            "name": "subType",
            "baseName": "sub_type",
            "type": "number"
        },
        {
            "name": "segments",
            "baseName": "segments",
            "type": "Array<SummarySegment>"
        },
        {
            "name": "directions",
            "baseName": "directions",
            "type": "Array<RouteDirection>"
        }    ];

    static getAttributeTypeMap() {
        return Route.attributeTypeMap;
    }
}

/**
*
*/
export class RouteDirection {
    /**
    * The distance in the route at which the action applies
    */
    'distance'?: number;
    /**
    * The action of this direction
    */
    'action'?: number;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RouteDirection.attributeTypeMap;
    }
}

export class RunningRace {
    /**
    * The unique identifier of this race.
    */
    'id'?: number;
    /**
    * The name of this race.
    */
    'name'?: string;
    /**
    * The type of this race.
    */
    'runningRaceType'?: number;
    /**
    * The race's distance, in meters.
    */
    'distance'?: number;
    /**
    * The time at which the race begins started in the local timezone.
    */
    'startDateLocal'?: Date;
    /**
    * The name of the city in which the race is taking place.
    */
    'city'?: string;
    /**
    * The name of the state or geographical region in which the race is taking place.
    */
    'state'?: string;
    /**
    * The name of the country in which the race is taking place.
    */
    'country'?: string;
    /**
    * The set of routes that cover this race's course.
    */
    'routeIds'?: Array<number>;
    /**
    * The unit system in which the race should be displayed.
    */
    'measurementPreference'?: RunningRace.MeasurementPreferenceEnum;
    /**
    * The vanity URL of this race on Strava.
    */
    'url'?: string;
    /**
    * The URL of this race's website.
    */
    'websiteUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "runningRaceType",
            "baseName": "running_race_type",
            "type": "number"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "startDateLocal",
            "baseName": "start_date_local",
            "type": "Date"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "routeIds",
            "baseName": "route_ids",
            "type": "Array<number>"
        },
        {
            "name": "measurementPreference",
            "baseName": "measurement_preference",
            "type": "RunningRace.MeasurementPreferenceEnum"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "websiteUrl",
            "baseName": "website_url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RunningRace.attributeTypeMap;
    }
}

export namespace RunningRace {
    export enum MeasurementPreferenceEnum {
        Feet = <any> 'feet',
        Meters = <any> 'meters'
    }
}
/**
* A
*/
export class SegmentLeaderboard {
    /**
    * The total number of entries for this leaderboard
    */
    'entryCount'?: number;
    /**
    * Deprecated, use entry_count
    */
    'effortCount'?: number;
    'komType'?: SegmentLeaderboard.KomTypeEnum;
    'entries'?: Array<SegmentLeaderboardEntry>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "entryCount",
            "baseName": "entry_count",
            "type": "number"
        },
        {
            "name": "effortCount",
            "baseName": "effort_count",
            "type": "number"
        },
        {
            "name": "komType",
            "baseName": "kom_type",
            "type": "SegmentLeaderboard.KomTypeEnum"
        },
        {
            "name": "entries",
            "baseName": "entries",
            "type": "Array<SegmentLeaderboardEntry>"
        }    ];

    static getAttributeTypeMap() {
        return SegmentLeaderboard.attributeTypeMap;
    }
}

export namespace SegmentLeaderboard {
    export enum KomTypeEnum {
        Kom = <any> 'kom',
        Cr = <any> 'cr'
    }
}
/**
* A row in a segment leaderboard
*/
export class SegmentLeaderboardEntry {
    /**
    * The public name of the athlete
    */
    'athleteName'?: string;
    /**
    * The elapsed of the segment effort associated with this entry
    */
    'elapsedTime'?: number;
    /**
    * The moving of the segment effort associated with this entry
    */
    'movingTime'?: number;
    /**
    * The time at which the effort was started.
    */
    'startDate'?: Date;
    /**
    * The time at which the effort was started in the local timezone.
    */
    'startDateLocal'?: Date;
    /**
    * The rank of this entry in the leaderboard
    */
    'rank'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "athleteName",
            "baseName": "athlete_name",
            "type": "string"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "movingTime",
            "baseName": "moving_time",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "startDateLocal",
            "baseName": "start_date_local",
            "type": "Date"
        },
        {
            "name": "rank",
            "baseName": "rank",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SegmentLeaderboardEntry.attributeTypeMap;
    }
}

export class Split {
    /**
    * The average speed of this split, in meters per second
    */
    'averageSpeed'?: number;
    /**
    * The distance of this split, in meters
    */
    'distance'?: number;
    /**
    * The elapsed time of this split, in seconds
    */
    'elapsedTime'?: number;
    /**
    * The elevation difference of this split, in meters
    */
    'elevationDifference'?: number;
    /**
    * The pacing zone of this split
    */
    'paceZone'?: number;
    /**
    * The moving time of this split, in seconds
    */
    'movingTime'?: number;
    /**
    * N/A
    */
    'split'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "averageSpeed",
            "baseName": "average_speed",
            "type": "number"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "elevationDifference",
            "baseName": "elevation_difference",
            "type": "number"
        },
        {
            "name": "paceZone",
            "baseName": "pace_zone",
            "type": "number"
        },
        {
            "name": "movingTime",
            "baseName": "moving_time",
            "type": "number"
        },
        {
            "name": "split",
            "baseName": "split",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Split.attributeTypeMap;
    }
}

export class StreamSet {
    'time'?: TimeStream;
    'distance'?: DistanceStream;
    'latlng'?: LatLngStream;
    'altitude'?: AltitudeStream;
    'velocitySmooth'?: SmoothVelocityStream;
    'heartrate'?: HeartrateStream;
    'cadence'?: CadenceStream;
    'watts'?: PowerStream;
    'temp'?: TemperatureStream;
    'moving'?: MovingStream;
    'gradeSmooth'?: SmoothGradeStream;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "TimeStream"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "DistanceStream"
        },
        {
            "name": "latlng",
            "baseName": "latlng",
            "type": "LatLngStream"
        },
        {
            "name": "altitude",
            "baseName": "altitude",
            "type": "AltitudeStream"
        },
        {
            "name": "velocitySmooth",
            "baseName": "velocity_smooth",
            "type": "SmoothVelocityStream"
        },
        {
            "name": "heartrate",
            "baseName": "heartrate",
            "type": "HeartrateStream"
        },
        {
            "name": "cadence",
            "baseName": "cadence",
            "type": "CadenceStream"
        },
        {
            "name": "watts",
            "baseName": "watts",
            "type": "PowerStream"
        },
        {
            "name": "temp",
            "baseName": "temp",
            "type": "TemperatureStream"
        },
        {
            "name": "moving",
            "baseName": "moving",
            "type": "MovingStream"
        },
        {
            "name": "gradeSmooth",
            "baseName": "grade_smooth",
            "type": "SmoothGradeStream"
        }    ];

    static getAttributeTypeMap() {
        return StreamSet.attributeTypeMap;
    }
}

export class SummaryGear {
    /**
    * The gear's unique identifier.
    */
    'id'?: string;
    /**
    * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
    */
    'resourceState'?: number;
    /**
    * Whether this gear's is the owner's default one.
    */
    'primary'?: boolean;
    /**
    * The gear's name.
    */
    'name'?: string;
    /**
    * The distance logged with this gear.
    */
    'distance'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "resourceState",
            "baseName": "resource_state",
            "type": "number"
        },
        {
            "name": "primary",
            "baseName": "primary",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SummaryGear.attributeTypeMap;
    }
}

export class SummarySegment {
    /**
    * The unique identifier of this segment
    */
    'id'?: number;
    /**
    * The name of this segment
    */
    'name'?: string;
    'activityType'?: SummarySegment.ActivityTypeEnum;
    /**
    * The segment's distance, in meters
    */
    'distance'?: number;
    /**
    * The segment's average grade, in percents
    */
    'averageGrade'?: number;
    /**
    * The segments's maximum grade, in percents
    */
    'maximumGrade'?: number;
    /**
    * The segments's highest elevation, in meters
    */
    'elevationHigh'?: number;
    /**
    * The segments's lowest elevation, in meters
    */
    'elevationLow'?: number;
    'startLatlng'?: LatLng;
    'endLatlng'?: LatLng;
    /**
    * The category of the climb
    */
    'climbCategory'?: number;
    /**
    * The segments's city.
    */
    'city'?: string;
    /**
    * The segments's state or geographical region.
    */
    'state'?: string;
    /**
    * The segment's country.
    */
    'country'?: string;
    /**
    * Whether this segment is private.
    */
    '_private'?: boolean;
    'athletePrEffort'?: SummarySegmentEffort;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "activityType",
            "baseName": "activity_type",
            "type": "SummarySegment.ActivityTypeEnum"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "averageGrade",
            "baseName": "average_grade",
            "type": "number"
        },
        {
            "name": "maximumGrade",
            "baseName": "maximum_grade",
            "type": "number"
        },
        {
            "name": "elevationHigh",
            "baseName": "elevation_high",
            "type": "number"
        },
        {
            "name": "elevationLow",
            "baseName": "elevation_low",
            "type": "number"
        },
        {
            "name": "startLatlng",
            "baseName": "start_latlng",
            "type": "LatLng"
        },
        {
            "name": "endLatlng",
            "baseName": "end_latlng",
            "type": "LatLng"
        },
        {
            "name": "climbCategory",
            "baseName": "climb_category",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "athletePrEffort",
            "baseName": "athlete_pr_effort",
            "type": "SummarySegmentEffort"
        }    ];

    static getAttributeTypeMap() {
        return SummarySegment.attributeTypeMap;
    }
}

export namespace SummarySegment {
    export enum ActivityTypeEnum {
        Ride = <any> 'Ride',
        Run = <any> 'Run'
    }
}
export class SummarySegmentEffort {
    /**
    * The unique identifier of this effort
    */
    'id'?: number;
    /**
    * The effort's elapsed time
    */
    'elapsedTime'?: number;
    /**
    * The time at which the effort was started.
    */
    'startDate'?: Date;
    /**
    * The time at which the effort was started in the local timezone.
    */
    'startDateLocal'?: Date;
    /**
    * The effort's distance in meters
    */
    'distance'?: number;
    /**
    * Whether this effort is the current best on the leaderboard
    */
    'isKom'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "startDateLocal",
            "baseName": "start_date_local",
            "type": "Date"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "isKom",
            "baseName": "is_kom",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SummarySegmentEffort.attributeTypeMap;
    }
}

/**
* Stores the exclusive ranges representing zones and the time spent in each.
*/
export class TimedZoneDistribution extends Array<TimedZoneRange> {

    static discriminator: string | undefined = undefined;

}

export class UpdatableActivity {
    /**
    * Whether this activity is a commute
    */
    'commute'?: boolean;
    /**
    * Whether this activity was recorded on a training machine
    */
    'trainer'?: boolean;
    /**
    * The description of the activity
    */
    'description'?: string;
    /**
    * The name of the activity
    */
    'name'?: string;
    'type'?: ActivityType;
    /**
    * Whether this activity is private
    */
    '_private'?: boolean;
    /**
    * Identifier for the gear associated with the activity. none clears gear from activity
    */
    'gearId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commute",
            "baseName": "commute",
            "type": "boolean"
        },
        {
            "name": "trainer",
            "baseName": "trainer",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ActivityType"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "gearId",
            "baseName": "gear_id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdatableActivity.attributeTypeMap;
    }
}

export class Upload {
    /**
    * The unique identifier of the upload
    */
    'id'?: number;
    /**
    * The external identifier of the upload
    */
    'externalId'?: string;
    /**
    * The error associated with this upload
    */
    'error'?: string;
    /**
    * The status of this upload
    */
    'status'?: string;
    /**
    * The identifier of the activity this upload resulted into
    */
    'activityId'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "externalId",
            "baseName": "external_id",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "activityId",
            "baseName": "activity_id",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Upload.attributeTypeMap;
    }
}

export class ZoneRange {
    /**
    * The minimum value in the range.
    */
    'min'?: number;
    /**
    * The maximum value in the range.
    */
    'max'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ZoneRange.attributeTypeMap;
    }
}

export class ZoneRanges extends Array<ZoneRange> {

    static discriminator: string | undefined = undefined;

}

export class Zones {
    'heartRate'?: HeartRateZoneRanges;
    'power'?: PowerZoneRanges;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "heartRate",
            "baseName": "heart_rate",
            "type": "HeartRateZoneRanges"
        },
        {
            "name": "power",
            "baseName": "power",
            "type": "PowerZoneRanges"
        }    ];

    static getAttributeTypeMap() {
        return Zones.attributeTypeMap;
    }
}

export class AltitudeStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: AltitudeStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: AltitudeStream.SeriesTypeEnum;
    /**
    * The sequence of altitude values for this stream, in meters
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "AltitudeStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "AltitudeStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return AltitudeStream.attributeTypeMap;
    }
}

export namespace AltitudeStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class CadenceStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: CadenceStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: CadenceStream.SeriesTypeEnum;
    /**
    * The sequence of cadence values for this stream, in rotations per minute
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "CadenceStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "CadenceStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return CadenceStream.attributeTypeMap;
    }
}

export namespace CadenceStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class DetailedGear {
    /**
    * The gear's unique identifier.
    */
    'id'?: string;
    /**
    * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
    */
    'resourceState'?: number;
    /**
    * Whether this gear's is the owner's default one.
    */
    'primary'?: boolean;
    /**
    * The gear's name.
    */
    'name'?: string;
    /**
    * The distance logged with this gear.
    */
    'distance'?: number;
    /**
    * The gear's brand name.
    */
    'brandName'?: string;
    /**
    * The gear's model name.
    */
    'modelName'?: string;
    /**
    * The gear's frame type (bike only).
    */
    'frameType'?: number;
    /**
    * The gear's description.
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "resourceState",
            "baseName": "resource_state",
            "type": "number"
        },
        {
            "name": "primary",
            "baseName": "primary",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "brandName",
            "baseName": "brand_name",
            "type": "string"
        },
        {
            "name": "modelName",
            "baseName": "model_name",
            "type": "string"
        },
        {
            "name": "frameType",
            "baseName": "frame_type",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DetailedGear.attributeTypeMap;
    }
}

export class DetailedSegment {
    /**
    * The unique identifier of this segment
    */
    'id'?: number;
    /**
    * The name of this segment
    */
    'name'?: string;
    'activityType'?: DetailedSegment.ActivityTypeEnum;
    /**
    * The segment's distance, in meters
    */
    'distance'?: number;
    /**
    * The segment's average grade, in percents
    */
    'averageGrade'?: number;
    /**
    * The segments's maximum grade, in percents
    */
    'maximumGrade'?: number;
    /**
    * The segments's highest elevation, in meters
    */
    'elevationHigh'?: number;
    /**
    * The segments's lowest elevation, in meters
    */
    'elevationLow'?: number;
    'startLatlng'?: LatLng;
    'endLatlng'?: LatLng;
    /**
    * The category of the climb
    */
    'climbCategory'?: number;
    /**
    * The segments's city.
    */
    'city'?: string;
    /**
    * The segments's state or geographical region.
    */
    'state'?: string;
    /**
    * The segment's country.
    */
    'country'?: string;
    /**
    * Whether this segment is private.
    */
    '_private'?: boolean;
    'athletePrEffort'?: SummarySegmentEffort;
    /**
    * The time at which the segment was created.
    */
    'createdAt'?: Date;
    /**
    * The time at which the segment was last updated.
    */
    'updatedAt'?: Date;
    /**
    * The segment's total elevation gain.
    */
    'totalElevationGain'?: number;
    'map'?: PolylineMap;
    /**
    * The total number of efforts for this segment
    */
    'effortCount'?: number;
    /**
    * The number of unique athletes who have an effort for this segment
    */
    'athleteCount'?: number;
    /**
    * Whether this segment is considered hazardous
    */
    'hazardous'?: boolean;
    /**
    * The number of stars for this segment
    */
    'starCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "activityType",
            "baseName": "activity_type",
            "type": "DetailedSegment.ActivityTypeEnum"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "averageGrade",
            "baseName": "average_grade",
            "type": "number"
        },
        {
            "name": "maximumGrade",
            "baseName": "maximum_grade",
            "type": "number"
        },
        {
            "name": "elevationHigh",
            "baseName": "elevation_high",
            "type": "number"
        },
        {
            "name": "elevationLow",
            "baseName": "elevation_low",
            "type": "number"
        },
        {
            "name": "startLatlng",
            "baseName": "start_latlng",
            "type": "LatLng"
        },
        {
            "name": "endLatlng",
            "baseName": "end_latlng",
            "type": "LatLng"
        },
        {
            "name": "climbCategory",
            "baseName": "climb_category",
            "type": "number"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "athletePrEffort",
            "baseName": "athlete_pr_effort",
            "type": "SummarySegmentEffort"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "totalElevationGain",
            "baseName": "total_elevation_gain",
            "type": "number"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "PolylineMap"
        },
        {
            "name": "effortCount",
            "baseName": "effort_count",
            "type": "number"
        },
        {
            "name": "athleteCount",
            "baseName": "athlete_count",
            "type": "number"
        },
        {
            "name": "hazardous",
            "baseName": "hazardous",
            "type": "boolean"
        },
        {
            "name": "starCount",
            "baseName": "star_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DetailedSegment.attributeTypeMap;
    }
}

export namespace DetailedSegment {
    export enum ActivityTypeEnum {
        Ride = <any> 'Ride',
        Run = <any> 'Run'
    }
}
export class DetailedSegmentEffort {
    /**
    * The unique identifier of this effort
    */
    'id'?: number;
    /**
    * The effort's elapsed time
    */
    'elapsedTime'?: number;
    /**
    * The time at which the effort was started.
    */
    'startDate'?: Date;
    /**
    * The time at which the effort was started in the local timezone.
    */
    'startDateLocal'?: Date;
    /**
    * The effort's distance in meters
    */
    'distance'?: number;
    /**
    * Whether this effort is the current best on the leaderboard
    */
    'isKom'?: boolean;
    /**
    * The name of the segment on which this effort was performed
    */
    'name'?: string;
    'activity'?: MetaActivity;
    'athlete'?: MetaAthlete;
    /**
    * The effort's moving time
    */
    'movingTime'?: number;
    /**
    * The start index of this effort in its activity's stream
    */
    'startIndex'?: number;
    /**
    * The end index of this effort in its activity's stream
    */
    'endIndex'?: number;
    /**
    * The effort's average cadence
    */
    'averageCadence'?: number;
    /**
    * The average wattage of this effort
    */
    'averageWatts'?: number;
    /**
    * For riding efforts, whether the wattage was reported by a dedicated recording device
    */
    'deviceWatts'?: boolean;
    /**
    * The heart heart rate of the athlete during this effort
    */
    'averageHeartrate'?: number;
    /**
    * The maximum heart rate of the athlete during this effort
    */
    'maxHeartrate'?: number;
    'segment'?: SummarySegment;
    /**
    * The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
    */
    'komRank'?: number;
    /**
    * The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
    */
    'prRank'?: number;
    /**
    * Whether this effort should be hidden when viewed within an activity
    */
    'hidden'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "startDateLocal",
            "baseName": "start_date_local",
            "type": "Date"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "isKom",
            "baseName": "is_kom",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "activity",
            "baseName": "activity",
            "type": "MetaActivity"
        },
        {
            "name": "athlete",
            "baseName": "athlete",
            "type": "MetaAthlete"
        },
        {
            "name": "movingTime",
            "baseName": "moving_time",
            "type": "number"
        },
        {
            "name": "startIndex",
            "baseName": "start_index",
            "type": "number"
        },
        {
            "name": "endIndex",
            "baseName": "end_index",
            "type": "number"
        },
        {
            "name": "averageCadence",
            "baseName": "average_cadence",
            "type": "number"
        },
        {
            "name": "averageWatts",
            "baseName": "average_watts",
            "type": "number"
        },
        {
            "name": "deviceWatts",
            "baseName": "device_watts",
            "type": "boolean"
        },
        {
            "name": "averageHeartrate",
            "baseName": "average_heartrate",
            "type": "number"
        },
        {
            "name": "maxHeartrate",
            "baseName": "max_heartrate",
            "type": "number"
        },
        {
            "name": "segment",
            "baseName": "segment",
            "type": "SummarySegment"
        },
        {
            "name": "komRank",
            "baseName": "kom_rank",
            "type": "number"
        },
        {
            "name": "prRank",
            "baseName": "pr_rank",
            "type": "number"
        },
        {
            "name": "hidden",
            "baseName": "hidden",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DetailedSegmentEffort.attributeTypeMap;
    }
}

export class DistanceStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: DistanceStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: DistanceStream.SeriesTypeEnum;
    /**
    * The sequence of distance values for this stream, in meters
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "DistanceStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "DistanceStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return DistanceStream.attributeTypeMap;
    }
}

export namespace DistanceStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class HeartrateStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: HeartrateStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: HeartrateStream.SeriesTypeEnum;
    /**
    * The sequence of heart rate values for this stream, in beats per minute
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "HeartrateStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "HeartrateStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return HeartrateStream.attributeTypeMap;
    }
}

export namespace HeartrateStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class LatLngStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: LatLngStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: LatLngStream.SeriesTypeEnum;
    /**
    * The sequence of lat/long values for this stream
    */
    'data'?: Array<LatLng>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "LatLngStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "LatLngStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<LatLng>"
        }    ];

    static getAttributeTypeMap() {
        return LatLngStream.attributeTypeMap;
    }
}

export namespace LatLngStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class MovingStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: MovingStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: MovingStream.SeriesTypeEnum;
    /**
    * The sequence of moving values for this stream, as boolean values
    */
    'data'?: Array<boolean>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "MovingStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "MovingStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<boolean>"
        }    ];

    static getAttributeTypeMap() {
        return MovingStream.attributeTypeMap;
    }
}

export namespace MovingStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class PowerStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: PowerStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: PowerStream.SeriesTypeEnum;
    /**
    * The sequence of power values for this stream, in watts
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "PowerStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "PowerStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return PowerStream.attributeTypeMap;
    }
}

export namespace PowerStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class SmoothGradeStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: SmoothGradeStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: SmoothGradeStream.SeriesTypeEnum;
    /**
    * The sequence of grade values for this stream, as percents of a grade
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "SmoothGradeStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "SmoothGradeStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return SmoothGradeStream.attributeTypeMap;
    }
}

export namespace SmoothGradeStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class SmoothVelocityStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: SmoothVelocityStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: SmoothVelocityStream.SeriesTypeEnum;
    /**
    * The sequence of velocity values for this stream, in meters per second
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "SmoothVelocityStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "SmoothVelocityStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return SmoothVelocityStream.attributeTypeMap;
    }
}

export namespace SmoothVelocityStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class SummaryActivity {
    /**
    * The unique identifier of the activity
    */
    'id'?: number;
    /**
    * The identifier provided at upload time
    */
    'externalId'?: string;
    /**
    * The identifier of the upload that resulted in this activity
    */
    'uploadId'?: number;
    'athlete'?: MetaAthlete;
    /**
    * The name of the activity
    */
    'name'?: string;
    /**
    * The activity's distance, in meters
    */
    'distance'?: number;
    /**
    * The activity's moving time, in seconds
    */
    'movingTime'?: number;
    /**
    * The activity's elapsed time, in seconds
    */
    'elapsedTime'?: number;
    /**
    * The activity's total elevation gain.
    */
    'totalElevationGain'?: number;
    /**
    * The activity's highest elevation, in meters
    */
    'elevHigh'?: number;
    /**
    * The activity's lowest elevation, in meters
    */
    'elevLow'?: number;
    'type'?: ActivityType;
    /**
    * The time at which the activity was started.
    */
    'startDate'?: Date;
    /**
    * The time at which the activity was started in the local timezone.
    */
    'startDateLocal'?: Date;
    /**
    * The timezone of the activity
    */
    'timezone'?: string;
    'startLatlng'?: LatLng;
    'endLatlng'?: LatLng;
    /**
    * The number of achievements gained during this activity
    */
    'achievementCount'?: number;
    /**
    * The number of kudos given for this activity
    */
    'kudosCount'?: number;
    /**
    * The number of comments for this activity
    */
    'commentCount'?: number;
    /**
    * The number of athletes for taking part in a group activity
    */
    'athleteCount'?: number;
    /**
    * The number of Instagram photos for this activity
    */
    'photoCount'?: number;
    /**
    * The number of Instagram and Strava photos for this activity
    */
    'totalPhotoCount'?: number;
    'map'?: PolylineMap;
    /**
    * Whether this activity was recorded on a training machine
    */
    'trainer'?: boolean;
    /**
    * Whether this activity is a commute
    */
    'commute'?: boolean;
    /**
    * Whether this activity was created manually
    */
    'manual'?: boolean;
    /**
    * Whether this activity is private
    */
    '_private'?: boolean;
    /**
    * Whether this activity is flagged
    */
    'flagged'?: boolean;
    /**
    * The activity's workout type
    */
    'workoutType'?: number;
    /**
    * The activity's average speed, in meters per second
    */
    'averageSpeed'?: number;
    /**
    * The activity's max speed, in meters per second
    */
    'maxSpeed'?: number;
    /**
    * Whether the logged-in athlete has kudoed this activity
    */
    'hasKudoed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "externalId",
            "baseName": "external_id",
            "type": "string"
        },
        {
            "name": "uploadId",
            "baseName": "upload_id",
            "type": "number"
        },
        {
            "name": "athlete",
            "baseName": "athlete",
            "type": "MetaAthlete"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "movingTime",
            "baseName": "moving_time",
            "type": "number"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "totalElevationGain",
            "baseName": "total_elevation_gain",
            "type": "number"
        },
        {
            "name": "elevHigh",
            "baseName": "elev_high",
            "type": "number"
        },
        {
            "name": "elevLow",
            "baseName": "elev_low",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ActivityType"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "startDateLocal",
            "baseName": "start_date_local",
            "type": "Date"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "startLatlng",
            "baseName": "start_latlng",
            "type": "LatLng"
        },
        {
            "name": "endLatlng",
            "baseName": "end_latlng",
            "type": "LatLng"
        },
        {
            "name": "achievementCount",
            "baseName": "achievement_count",
            "type": "number"
        },
        {
            "name": "kudosCount",
            "baseName": "kudos_count",
            "type": "number"
        },
        {
            "name": "commentCount",
            "baseName": "comment_count",
            "type": "number"
        },
        {
            "name": "athleteCount",
            "baseName": "athlete_count",
            "type": "number"
        },
        {
            "name": "photoCount",
            "baseName": "photo_count",
            "type": "number"
        },
        {
            "name": "totalPhotoCount",
            "baseName": "total_photo_count",
            "type": "number"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "PolylineMap"
        },
        {
            "name": "trainer",
            "baseName": "trainer",
            "type": "boolean"
        },
        {
            "name": "commute",
            "baseName": "commute",
            "type": "boolean"
        },
        {
            "name": "manual",
            "baseName": "manual",
            "type": "boolean"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "flagged",
            "baseName": "flagged",
            "type": "boolean"
        },
        {
            "name": "workoutType",
            "baseName": "workout_type",
            "type": "number"
        },
        {
            "name": "averageSpeed",
            "baseName": "average_speed",
            "type": "number"
        },
        {
            "name": "maxSpeed",
            "baseName": "max_speed",
            "type": "number"
        },
        {
            "name": "hasKudoed",
            "baseName": "has_kudoed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SummaryActivity.attributeTypeMap;
    }
}

export class SummaryAthlete {
    /**
    * The unique identifier of the athlete
    */
    'id'?: number;
    /**
    * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
    */
    'resourceState'?: number;
    /**
    * The athlete's first name.
    */
    'firstname'?: string;
    /**
    * The athlete's last name.
    */
    'lastname'?: string;
    /**
    * URL to a 62x62 pixel profile picture.
    */
    'profileMedium'?: string;
    /**
    * URL to a 124x124 pixel profile picture.
    */
    'profile'?: string;
    /**
    * The athlete's city.
    */
    'city'?: string;
    /**
    * The athlete's state or geographical region.
    */
    'state'?: string;
    /**
    * The athlete's country.
    */
    'country'?: string;
    /**
    * The athlete's sex.
    */
    'sex'?: SummaryAthlete.SexEnum;
    /**
    * Whether the currently logged-in athlete follows this athlete.
    */
    'friend'?: SummaryAthlete.FriendEnum;
    /**
    * Whether this athlete follows the currently logged-in athlete.
    */
    'follower'?: SummaryAthlete.FollowerEnum;
    /**
    * The athlete's premium status.
    */
    'premium'?: boolean;
    /**
    * The time at which the athlete was created.
    */
    'createdAt'?: Date;
    /**
    * The time at which the athlete was last updated.
    */
    'updatedAt'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "resourceState",
            "baseName": "resource_state",
            "type": "number"
        },
        {
            "name": "firstname",
            "baseName": "firstname",
            "type": "string"
        },
        {
            "name": "lastname",
            "baseName": "lastname",
            "type": "string"
        },
        {
            "name": "profileMedium",
            "baseName": "profile_medium",
            "type": "string"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "sex",
            "baseName": "sex",
            "type": "SummaryAthlete.SexEnum"
        },
        {
            "name": "friend",
            "baseName": "friend",
            "type": "SummaryAthlete.FriendEnum"
        },
        {
            "name": "follower",
            "baseName": "follower",
            "type": "SummaryAthlete.FollowerEnum"
        },
        {
            "name": "premium",
            "baseName": "premium",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return SummaryAthlete.attributeTypeMap;
    }
}

export namespace SummaryAthlete {
    export enum SexEnum {
        M = <any> 'M',
        F = <any> 'F'
    }
    export enum FriendEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
    export enum FollowerEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
}
export class SummaryClub {
    /**
    * The club's unique identifier.
    */
    'id'?: number;
    /**
    * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
    */
    'resourceState'?: number;
    /**
    * The club's name.
    */
    'name'?: string;
    /**
    * URL to a 60x60 pixel profile picture.
    */
    'profileMedium'?: string;
    /**
    * URL to a ~1185x580 pixel cover photo.
    */
    'coverPhoto'?: string;
    /**
    * URL to a ~360x176  pixel cover photo.
    */
    'coverPhotoSmall'?: string;
    'sportType'?: SummaryClub.SportTypeEnum;
    /**
    * The club's city.
    */
    'city'?: string;
    /**
    * The club's state or geographical region.
    */
    'state'?: string;
    /**
    * The club's country.
    */
    'country'?: string;
    /**
    * Whether the club is private.
    */
    '_private'?: boolean;
    /**
    * The club's member count.
    */
    'memberCount'?: number;
    /**
    * Whether the club is featured or not.
    */
    'featured'?: boolean;
    /**
    * Whether the club is verified or not.
    */
    'verified'?: boolean;
    /**
    * The club's vanity URL.
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "resourceState",
            "baseName": "resource_state",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "profileMedium",
            "baseName": "profile_medium",
            "type": "string"
        },
        {
            "name": "coverPhoto",
            "baseName": "cover_photo",
            "type": "string"
        },
        {
            "name": "coverPhotoSmall",
            "baseName": "cover_photo_small",
            "type": "string"
        },
        {
            "name": "sportType",
            "baseName": "sport_type",
            "type": "SummaryClub.SportTypeEnum"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "memberCount",
            "baseName": "member_count",
            "type": "number"
        },
        {
            "name": "featured",
            "baseName": "featured",
            "type": "boolean"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SummaryClub.attributeTypeMap;
    }
}

export namespace SummaryClub {
    export enum SportTypeEnum {
        Cycling = <any> 'cycling',
        Running = <any> 'running',
        Triathlon = <any> 'triathlon',
        Other = <any> 'other'
    }
}
export class TemperatureStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: TemperatureStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: TemperatureStream.SeriesTypeEnum;
    /**
    * The sequence of temperature values for this stream, in celsius degrees
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "TemperatureStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "TemperatureStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TemperatureStream.attributeTypeMap;
    }
}

export namespace TemperatureStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
export class TimeStream {
    /**
    * The number of data points in this stream
    */
    'originalSize'?: number;
    /**
    * The level of detail (sampling) in which this stream was returned
    */
    'resolution'?: TimeStream.ResolutionEnum;
    /**
    * The base series used in the case the stream was downsampled
    */
    'seriesType'?: TimeStream.SeriesTypeEnum;
    /**
    * The sequence of time values for this stream, in seconds
    */
    'data'?: Array<number>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalSize",
            "baseName": "original_size",
            "type": "number"
        },
        {
            "name": "resolution",
            "baseName": "resolution",
            "type": "TimeStream.ResolutionEnum"
        },
        {
            "name": "seriesType",
            "baseName": "series_type",
            "type": "TimeStream.SeriesTypeEnum"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<number>"
        }    ];

    static getAttributeTypeMap() {
        return TimeStream.attributeTypeMap;
    }
}

export namespace TimeStream {
    export enum ResolutionEnum {
        Low = <any> 'low',
        Medium = <any> 'medium',
        High = <any> 'high'
    }
    export enum SeriesTypeEnum {
        Distance = <any> 'distance',
        Time = <any> 'time'
    }
}
/**
* A union type representing the time spent in a given zone.
*/
export class TimedZoneRange {
    /**
    * The minimum value in the range.
    */
    'min'?: number;
    /**
    * The maximum value in the range.
    */
    'max'?: number;
    /**
    * The number of seconds spent in this zone
    */
    'time'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TimedZoneRange.attributeTypeMap;
    }
}

export class DetailedActivity {
    /**
    * The unique identifier of the activity
    */
    'id'?: number;
    /**
    * The identifier provided at upload time
    */
    'externalId'?: string;
    /**
    * The identifier of the upload that resulted in this activity
    */
    'uploadId'?: number;
    'athlete'?: MetaAthlete;
    /**
    * The name of the activity
    */
    'name'?: string;
    /**
    * The activity's distance, in meters
    */
    'distance'?: number;
    /**
    * The activity's moving time, in seconds
    */
    'movingTime'?: number;
    /**
    * The activity's elapsed time, in seconds
    */
    'elapsedTime'?: number;
    /**
    * The activity's total elevation gain.
    */
    'totalElevationGain'?: number;
    /**
    * The activity's highest elevation, in meters
    */
    'elevHigh'?: number;
    /**
    * The activity's lowest elevation, in meters
    */
    'elevLow'?: number;
    'type'?: ActivityType;
    /**
    * The time at which the activity was started.
    */
    'startDate'?: Date;
    /**
    * The time at which the activity was started in the local timezone.
    */
    'startDateLocal'?: Date;
    /**
    * The timezone of the activity
    */
    'timezone'?: string;
    'startLatlng'?: LatLng;
    'endLatlng'?: LatLng;
    /**
    * The number of achievements gained during this activity
    */
    'achievementCount'?: number;
    /**
    * The number of kudos given for this activity
    */
    'kudosCount'?: number;
    /**
    * The number of comments for this activity
    */
    'commentCount'?: number;
    /**
    * The number of athletes for taking part in a group activity
    */
    'athleteCount'?: number;
    /**
    * The number of Instagram photos for this activity
    */
    'photoCount'?: number;
    /**
    * The number of Instagram and Strava photos for this activity
    */
    'totalPhotoCount'?: number;
    'map'?: PolylineMap;
    /**
    * Whether this activity was recorded on a training machine
    */
    'trainer'?: boolean;
    /**
    * Whether this activity is a commute
    */
    'commute'?: boolean;
    /**
    * Whether this activity was created manually
    */
    'manual'?: boolean;
    /**
    * Whether this activity is private
    */
    '_private'?: boolean;
    /**
    * Whether this activity is flagged
    */
    'flagged'?: boolean;
    /**
    * The activity's workout type
    */
    'workoutType'?: number;
    /**
    * The activity's average speed, in meters per second
    */
    'averageSpeed'?: number;
    /**
    * The activity's max speed, in meters per second
    */
    'maxSpeed'?: number;
    /**
    * Whether the logged-in athlete has kudoed this activity
    */
    'hasKudoed'?: boolean;
    /**
    * The description of the activity
    */
    'description'?: string;
    'photos'?: PhotosSummary;
    'gear'?: SummaryGear;
    /**
    * The number of kilocalories consumed during this activity
    */
    'calories'?: number;
    'segmentEfforts'?: Array<DetailedSegmentEffort>;
    /**
    * The name of the device used to record the activity
    */
    'deviceName'?: string;
    /**
    * The token used to embed a Strava activity
    */
    'embedToken'?: string;
    /**
    * The splits of this activity in metric units (for runs)
    */
    'splitsMetric'?: Array<Split>;
    /**
    * The splits of this activity in imperial units (for runs)
    */
    'splitsStandard'?: Array<Split>;
    'laps'?: Array<Lap>;
    'bestEfforts'?: Array<DetailedSegmentEffort>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "externalId",
            "baseName": "external_id",
            "type": "string"
        },
        {
            "name": "uploadId",
            "baseName": "upload_id",
            "type": "number"
        },
        {
            "name": "athlete",
            "baseName": "athlete",
            "type": "MetaAthlete"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "distance",
            "baseName": "distance",
            "type": "number"
        },
        {
            "name": "movingTime",
            "baseName": "moving_time",
            "type": "number"
        },
        {
            "name": "elapsedTime",
            "baseName": "elapsed_time",
            "type": "number"
        },
        {
            "name": "totalElevationGain",
            "baseName": "total_elevation_gain",
            "type": "number"
        },
        {
            "name": "elevHigh",
            "baseName": "elev_high",
            "type": "number"
        },
        {
            "name": "elevLow",
            "baseName": "elev_low",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ActivityType"
        },
        {
            "name": "startDate",
            "baseName": "start_date",
            "type": "Date"
        },
        {
            "name": "startDateLocal",
            "baseName": "start_date_local",
            "type": "Date"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "startLatlng",
            "baseName": "start_latlng",
            "type": "LatLng"
        },
        {
            "name": "endLatlng",
            "baseName": "end_latlng",
            "type": "LatLng"
        },
        {
            "name": "achievementCount",
            "baseName": "achievement_count",
            "type": "number"
        },
        {
            "name": "kudosCount",
            "baseName": "kudos_count",
            "type": "number"
        },
        {
            "name": "commentCount",
            "baseName": "comment_count",
            "type": "number"
        },
        {
            "name": "athleteCount",
            "baseName": "athlete_count",
            "type": "number"
        },
        {
            "name": "photoCount",
            "baseName": "photo_count",
            "type": "number"
        },
        {
            "name": "totalPhotoCount",
            "baseName": "total_photo_count",
            "type": "number"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "PolylineMap"
        },
        {
            "name": "trainer",
            "baseName": "trainer",
            "type": "boolean"
        },
        {
            "name": "commute",
            "baseName": "commute",
            "type": "boolean"
        },
        {
            "name": "manual",
            "baseName": "manual",
            "type": "boolean"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "flagged",
            "baseName": "flagged",
            "type": "boolean"
        },
        {
            "name": "workoutType",
            "baseName": "workout_type",
            "type": "number"
        },
        {
            "name": "averageSpeed",
            "baseName": "average_speed",
            "type": "number"
        },
        {
            "name": "maxSpeed",
            "baseName": "max_speed",
            "type": "number"
        },
        {
            "name": "hasKudoed",
            "baseName": "has_kudoed",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "photos",
            "baseName": "photos",
            "type": "PhotosSummary"
        },
        {
            "name": "gear",
            "baseName": "gear",
            "type": "SummaryGear"
        },
        {
            "name": "calories",
            "baseName": "calories",
            "type": "number"
        },
        {
            "name": "segmentEfforts",
            "baseName": "segment_efforts",
            "type": "Array<DetailedSegmentEffort>"
        },
        {
            "name": "deviceName",
            "baseName": "device_name",
            "type": "string"
        },
        {
            "name": "embedToken",
            "baseName": "embed_token",
            "type": "string"
        },
        {
            "name": "splitsMetric",
            "baseName": "splits_metric",
            "type": "Array<Split>"
        },
        {
            "name": "splitsStandard",
            "baseName": "splits_standard",
            "type": "Array<Split>"
        },
        {
            "name": "laps",
            "baseName": "laps",
            "type": "Array<Lap>"
        },
        {
            "name": "bestEfforts",
            "baseName": "best_efforts",
            "type": "Array<DetailedSegmentEffort>"
        }    ];

    static getAttributeTypeMap() {
        return DetailedActivity.attributeTypeMap;
    }
}

export class DetailedAthlete {
    /**
    * The unique identifier of the athlete
    */
    'id'?: number;
    /**
    * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
    */
    'resourceState'?: number;
    /**
    * The athlete's first name.
    */
    'firstname'?: string;
    /**
    * The athlete's last name.
    */
    'lastname'?: string;
    /**
    * URL to a 62x62 pixel profile picture.
    */
    'profileMedium'?: string;
    /**
    * URL to a 124x124 pixel profile picture.
    */
    'profile'?: string;
    /**
    * The athlete's city.
    */
    'city'?: string;
    /**
    * The athlete's state or geographical region.
    */
    'state'?: string;
    /**
    * The athlete's country.
    */
    'country'?: string;
    /**
    * The athlete's sex.
    */
    'sex'?: DetailedAthlete.SexEnum;
    /**
    * Whether the currently logged-in athlete follows this athlete.
    */
    'friend'?: DetailedAthlete.FriendEnum;
    /**
    * Whether this athlete follows the currently logged-in athlete.
    */
    'follower'?: DetailedAthlete.FollowerEnum;
    /**
    * The athlete's premium status.
    */
    'premium'?: boolean;
    /**
    * The time at which the athlete was created.
    */
    'createdAt'?: Date;
    /**
    * The time at which the athlete was last updated.
    */
    'updatedAt'?: Date;
    /**
    * The athlete's follower count.
    */
    'followerCount'?: number;
    /**
    * The athlete's friend count.
    */
    'friendCount'?: number;
    /**
    * The number or athletes mutually followed by this athlete and the currently logged-in athlete.
    */
    'mutualFriendCount'?: number;
    /**
    * The athlete's preferred unit system.
    */
    'measurementPreference'?: DetailedAthlete.MeasurementPreferenceEnum;
    /**
    * The athlete's email address.
    */
    'email'?: string;
    /**
    * The athlete's FTP (Functional Threshold Power).
    */
    'ftp'?: number;
    /**
    * The athlete's weight.
    */
    'weight'?: number;
    /**
    * The athlete's clubs.
    */
    'clubs'?: Array<SummaryClub>;
    /**
    * The athlete's bikes.
    */
    'bikes'?: Array<SummaryGear>;
    /**
    * The athlete's shoes.
    */
    'shoes'?: Array<SummaryGear>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "resourceState",
            "baseName": "resource_state",
            "type": "number"
        },
        {
            "name": "firstname",
            "baseName": "firstname",
            "type": "string"
        },
        {
            "name": "lastname",
            "baseName": "lastname",
            "type": "string"
        },
        {
            "name": "profileMedium",
            "baseName": "profile_medium",
            "type": "string"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "sex",
            "baseName": "sex",
            "type": "DetailedAthlete.SexEnum"
        },
        {
            "name": "friend",
            "baseName": "friend",
            "type": "DetailedAthlete.FriendEnum"
        },
        {
            "name": "follower",
            "baseName": "follower",
            "type": "DetailedAthlete.FollowerEnum"
        },
        {
            "name": "premium",
            "baseName": "premium",
            "type": "boolean"
        },
        {
            "name": "createdAt",
            "baseName": "created_at",
            "type": "Date"
        },
        {
            "name": "updatedAt",
            "baseName": "updated_at",
            "type": "Date"
        },
        {
            "name": "followerCount",
            "baseName": "follower_count",
            "type": "number"
        },
        {
            "name": "friendCount",
            "baseName": "friend_count",
            "type": "number"
        },
        {
            "name": "mutualFriendCount",
            "baseName": "mutual_friend_count",
            "type": "number"
        },
        {
            "name": "measurementPreference",
            "baseName": "measurement_preference",
            "type": "DetailedAthlete.MeasurementPreferenceEnum"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "ftp",
            "baseName": "ftp",
            "type": "number"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "number"
        },
        {
            "name": "clubs",
            "baseName": "clubs",
            "type": "Array<SummaryClub>"
        },
        {
            "name": "bikes",
            "baseName": "bikes",
            "type": "Array<SummaryGear>"
        },
        {
            "name": "shoes",
            "baseName": "shoes",
            "type": "Array<SummaryGear>"
        }    ];

    static getAttributeTypeMap() {
        return DetailedAthlete.attributeTypeMap;
    }
}

export namespace DetailedAthlete {
    export enum SexEnum {
        M = <any> 'M',
        F = <any> 'F'
    }
    export enum FriendEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
    export enum FollowerEnum {
        Pending = <any> 'pending',
        Accepted = <any> 'accepted',
        Blocked = <any> 'blocked'
    }
    export enum MeasurementPreferenceEnum {
        Feet = <any> 'feet',
        Meters = <any> 'meters'
    }
}
export class DetailedClub {
    /**
    * The club's unique identifier.
    */
    'id'?: number;
    /**
    * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
    */
    'resourceState'?: number;
    /**
    * The club's name.
    */
    'name'?: string;
    /**
    * URL to a 60x60 pixel profile picture.
    */
    'profileMedium'?: string;
    /**
    * URL to a ~1185x580 pixel cover photo.
    */
    'coverPhoto'?: string;
    /**
    * URL to a ~360x176  pixel cover photo.
    */
    'coverPhotoSmall'?: string;
    'sportType'?: DetailedClub.SportTypeEnum;
    /**
    * The club's city.
    */
    'city'?: string;
    /**
    * The club's state or geographical region.
    */
    'state'?: string;
    /**
    * The club's country.
    */
    'country'?: string;
    /**
    * Whether the club is private.
    */
    '_private'?: boolean;
    /**
    * The club's member count.
    */
    'memberCount'?: number;
    /**
    * Whether the club is featured or not.
    */
    'featured'?: boolean;
    /**
    * Whether the club is verified or not.
    */
    'verified'?: boolean;
    /**
    * The club's vanity URL.
    */
    'url'?: string;
    /**
    * The membership status of the logged-in athlete.
    */
    'membership'?: DetailedClub.MembershipEnum;
    /**
    * Whether the currently logged-in athlete is an administrator of this club.
    */
    'admin'?: boolean;
    /**
    * Whether the currently logged-in athlete is the owner of this club.
    */
    'owner'?: boolean;
    /**
    * The number of athletes in the club that the logged-in athlete follows.
    */
    'followingCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "resourceState",
            "baseName": "resource_state",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "profileMedium",
            "baseName": "profile_medium",
            "type": "string"
        },
        {
            "name": "coverPhoto",
            "baseName": "cover_photo",
            "type": "string"
        },
        {
            "name": "coverPhotoSmall",
            "baseName": "cover_photo_small",
            "type": "string"
        },
        {
            "name": "sportType",
            "baseName": "sport_type",
            "type": "DetailedClub.SportTypeEnum"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "_private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "memberCount",
            "baseName": "member_count",
            "type": "number"
        },
        {
            "name": "featured",
            "baseName": "featured",
            "type": "boolean"
        },
        {
            "name": "verified",
            "baseName": "verified",
            "type": "boolean"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "membership",
            "baseName": "membership",
            "type": "DetailedClub.MembershipEnum"
        },
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "boolean"
        },
        {
            "name": "followingCount",
            "baseName": "following_count",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DetailedClub.attributeTypeMap;
    }
}

export namespace DetailedClub {
    export enum SportTypeEnum {
        Cycling = <any> 'cycling',
        Running = <any> 'running',
        Triathlon = <any> 'triathlon',
        Other = <any> 'other'
    }
    export enum MembershipEnum {
        Member = <any> 'member',
        Pending = <any> 'pending'
    }
}

let enumsMap: {[index: string]: any} = {
        "ActivityZone.TypeEnum": ActivityZone.TypeEnum,
        "BaseStream.ResolutionEnum": BaseStream.ResolutionEnum,
        "BaseStream.SeriesTypeEnum": BaseStream.SeriesTypeEnum,
        "ExplorerSegment.ClimbCategoryDescEnum": ExplorerSegment.ClimbCategoryDescEnum,
        "MembershipApplication.MembershipEnum": MembershipApplication.MembershipEnum,
        "RunningRace.MeasurementPreferenceEnum": RunningRace.MeasurementPreferenceEnum,
        "SegmentLeaderboard.KomTypeEnum": SegmentLeaderboard.KomTypeEnum,
        "SummarySegment.ActivityTypeEnum": SummarySegment.ActivityTypeEnum,
        "AltitudeStream.ResolutionEnum": AltitudeStream.ResolutionEnum,
        "AltitudeStream.SeriesTypeEnum": AltitudeStream.SeriesTypeEnum,
        "CadenceStream.ResolutionEnum": CadenceStream.ResolutionEnum,
        "CadenceStream.SeriesTypeEnum": CadenceStream.SeriesTypeEnum,
        "DetailedSegment.ActivityTypeEnum": DetailedSegment.ActivityTypeEnum,
        "DistanceStream.ResolutionEnum": DistanceStream.ResolutionEnum,
        "DistanceStream.SeriesTypeEnum": DistanceStream.SeriesTypeEnum,
        "HeartrateStream.ResolutionEnum": HeartrateStream.ResolutionEnum,
        "HeartrateStream.SeriesTypeEnum": HeartrateStream.SeriesTypeEnum,
        "LatLngStream.ResolutionEnum": LatLngStream.ResolutionEnum,
        "LatLngStream.SeriesTypeEnum": LatLngStream.SeriesTypeEnum,
        "MovingStream.ResolutionEnum": MovingStream.ResolutionEnum,
        "MovingStream.SeriesTypeEnum": MovingStream.SeriesTypeEnum,
        "PowerStream.ResolutionEnum": PowerStream.ResolutionEnum,
        "PowerStream.SeriesTypeEnum": PowerStream.SeriesTypeEnum,
        "SmoothGradeStream.ResolutionEnum": SmoothGradeStream.ResolutionEnum,
        "SmoothGradeStream.SeriesTypeEnum": SmoothGradeStream.SeriesTypeEnum,
        "SmoothVelocityStream.ResolutionEnum": SmoothVelocityStream.ResolutionEnum,
        "SmoothVelocityStream.SeriesTypeEnum": SmoothVelocityStream.SeriesTypeEnum,
        "SummaryAthlete.SexEnum": SummaryAthlete.SexEnum,
        "SummaryAthlete.FriendEnum": SummaryAthlete.FriendEnum,
        "SummaryAthlete.FollowerEnum": SummaryAthlete.FollowerEnum,
        "SummaryClub.SportTypeEnum": SummaryClub.SportTypeEnum,
        "TemperatureStream.ResolutionEnum": TemperatureStream.ResolutionEnum,
        "TemperatureStream.SeriesTypeEnum": TemperatureStream.SeriesTypeEnum,
        "TimeStream.ResolutionEnum": TimeStream.ResolutionEnum,
        "TimeStream.SeriesTypeEnum": TimeStream.SeriesTypeEnum,
        "DetailedAthlete.SexEnum": DetailedAthlete.SexEnum,
        "DetailedAthlete.FriendEnum": DetailedAthlete.FriendEnum,
        "DetailedAthlete.FollowerEnum": DetailedAthlete.FollowerEnum,
        "DetailedAthlete.MeasurementPreferenceEnum": DetailedAthlete.MeasurementPreferenceEnum,
        "DetailedClub.SportTypeEnum": DetailedClub.SportTypeEnum,
        "DetailedClub.MembershipEnum": DetailedClub.MembershipEnum,
}

let typeMap: {[index: string]: any} = {
    "ActivityStats": ActivityStats,
    "ActivityTotal": ActivityTotal,
    "ActivityType": ActivityType,
    "ActivityZone": ActivityZone,
    "BaseStream": BaseStream,
    "Comment": Comment,
    "ExplorerResponse": ExplorerResponse,
    "ExplorerSegment": ExplorerSegment,
    "Fault": Fault,
    "HeartRateZoneRanges": HeartRateZoneRanges,
    "Lap": Lap,
    "LatLng": LatLng,
    "MembershipApplication": MembershipApplication,
    "MetaActivity": MetaActivity,
    "MetaAthlete": MetaAthlete,
    "MetaClub": MetaClub,
    "ModelError": ModelError,
    "PhotosSummary": PhotosSummary,
    "PhotosSummaryPrimary": PhotosSummaryPrimary,
    "PolylineMap": PolylineMap,
    "PowerZoneRanges": PowerZoneRanges,
    "Route": Route,
    "RouteDirection": RouteDirection,
    "RunningRace": RunningRace,
    "SegmentLeaderboard": SegmentLeaderboard,
    "SegmentLeaderboardEntry": SegmentLeaderboardEntry,
    "Split": Split,
    "StreamSet": StreamSet,
    "SummaryGear": SummaryGear,
    "SummarySegment": SummarySegment,
    "SummarySegmentEffort": SummarySegmentEffort,
    "TimedZoneDistribution": TimedZoneDistribution,
    "UpdatableActivity": UpdatableActivity,
    "Upload": Upload,
    "ZoneRange": ZoneRange,
    "ZoneRanges": ZoneRanges,
    "Zones": Zones,
    "AltitudeStream": AltitudeStream,
    "CadenceStream": CadenceStream,
    "DetailedGear": DetailedGear,
    "DetailedSegment": DetailedSegment,
    "DetailedSegmentEffort": DetailedSegmentEffort,
    "DistanceStream": DistanceStream,
    "HeartrateStream": HeartrateStream,
    "LatLngStream": LatLngStream,
    "MovingStream": MovingStream,
    "PowerStream": PowerStream,
    "SmoothGradeStream": SmoothGradeStream,
    "SmoothVelocityStream": SmoothVelocityStream,
    "SummaryActivity": SummaryActivity,
    "SummaryAthlete": SummaryAthlete,
    "SummaryClub": SummaryClub,
    "TemperatureStream": TemperatureStream,
    "TimeStream": TimeStream,
    "TimedZoneRange": TimedZoneRange,
    "DetailedActivity": DetailedActivity,
    "DetailedAthlete": DetailedAthlete,
    "DetailedClub": DetailedClub,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ActivitiesApiApiKeys {
}

export class ActivitiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActivitiesApiApiKeys, value: string) {
        (this.authentications as any)[ActivitiesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Creates a manual activity for an athlete. Requires write permissions, as requested during the authorization process.
     * @summary Create an Activity
     * @param name The name of the activity.
     * @param type Type of activity. For example - Run, Ride etc.
     * @param startDateLocal ISO 8601 formatted date time.
     * @param elapsedTime In seconds.
     * @param description Description of the activity.
     * @param distance In meters.
     * @param _private set to 1 to mark the resulting activity as private, view_private permissions will be necessary to view the activity. If not specified, set according to the athletes privacy setting (recommended).
     * @param trainer Set to 1 to mark as a trainer activity.
     * @param photoIds List of native photo ids to attach to the activity.
     * @param commute Set to 1 to mark as commute.
     */
    public createActivity (name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: number, _private?: number, trainer?: number, photoIds?: number[], commute?: number) : Promise<{ response: http.ClientResponse; body: DetailedActivity;  }> {
        const localVarPath = this.basePath + '/activities';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createActivity.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling createActivity.');
        }

        // verify required parameter 'startDateLocal' is not null or undefined
        if (startDateLocal === null || startDateLocal === undefined) {
            throw new Error('Required parameter startDateLocal was null or undefined when calling createActivity.');
        }

        // verify required parameter 'elapsedTime' is not null or undefined
        if (elapsedTime === null || elapsedTime === undefined) {
            throw new Error('Required parameter elapsedTime was null or undefined when calling createActivity.');
        }


        let localVarUseFormData = false;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (startDateLocal !== undefined) {
            localVarFormParams['start_date_local'] = ObjectSerializer.serialize(startDateLocal, "string");
        }

        if (elapsedTime !== undefined) {
            localVarFormParams['elapsed_time'] = ObjectSerializer.serialize(elapsedTime, "number");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (distance !== undefined) {
            localVarFormParams['distance'] = ObjectSerializer.serialize(distance, "number");
        }

        if (_private !== undefined) {
            localVarFormParams['private'] = ObjectSerializer.serialize(_private, "number");
        }

        if (trainer !== undefined) {
            localVarFormParams['trainer'] = ObjectSerializer.serialize(trainer, "number");
        }

        if (photoIds !== undefined) {
            localVarFormParams['photo_ids'] = ObjectSerializer.serialize(photoIds, "Array<number>");
        }

        if (commute !== undefined) {
            localVarFormParams['commute'] = ObjectSerializer.serialize(commute, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedActivity;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedActivity");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the given activity that is owned by the authenticated athlete.
     * @summary Get Activity
     * @param id The identifier of the activity.
     * @param includeAllEfforts To include all segments efforts.
     */
    public getActivityById (id: number, includeAllEfforts?: boolean) : Promise<{ response: http.ClientResponse; body: DetailedActivity;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivityById.');
        }

        if (includeAllEfforts !== undefined) {
            localVarQueryParameters['include_all_efforts'] = ObjectSerializer.serialize(includeAllEfforts, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedActivity;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedActivity");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the comments on the given activity.
     * @summary List Activity Comments
     * @param id The identifier of the activity.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getCommentsByActivityId (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<Comment>;  }> {
        const localVarPath = this.basePath + '/activities/{id}/comments'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCommentsByActivityId.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Comment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Comment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the athletes who kudoed an activity identified by an identifier.
     * @summary List Activity Kudoers
     * @param id The identifier of the activity.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getKudoersByActivityId (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<SummaryAthlete>;  }> {
        const localVarPath = this.basePath + '/activities/{id}/kudos'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getKudoersByActivityId.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SummaryAthlete>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SummaryAthlete>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the laps of an activity identified by an identifier.
     * @summary List Activity Laps
     * @param id The identifier of the activity.
     */
    public getLapsByActivityId (id: number) : Promise<{ response: http.ClientResponse; body: Array<Lap>;  }> {
        const localVarPath = this.basePath + '/activities/{id}/laps'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLapsByActivityId.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Lap>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Lap>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the activities of an athlete for a specific identifier.
     * @summary List Athlete Activities
     * @param before An epoch timestamp to use for filtering activities that have taken place before a certain time.
     * @param after An epoch timestamp to use for filtering activities that have taken place after a certain time.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getLoggedInAthleteActivities (before?: number, after?: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<SummaryActivity>;  }> {
        const localVarPath = this.basePath + '/athlete/activities';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (before !== undefined) {
            localVarQueryParameters['before'] = ObjectSerializer.serialize(before, "number");
        }

        if (after !== undefined) {
            localVarQueryParameters['after'] = ObjectSerializer.serialize(after, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SummaryActivity>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SummaryActivity>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Premium Feature. Returns the zones of a given activity.
     * @summary Get Activity Zones
     * @param id The identifier of the activity.
     */
    public getZonesByActivityId (id: number) : Promise<{ response: http.ClientResponse; body: Array<ActivityZone>;  }> {
        const localVarPath = this.basePath + '/activities/{id}/zones'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getZonesByActivityId.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<ActivityZone>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ActivityZone>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Updates the given activity that is owned by the authenticated athlete.
     * @summary Update Activity
     * @param id The identifier of the activity.
     * @param body
     */
    public updateActivityById (id: number, body?: UpdatableActivity) : Promise<{ response: http.ClientResponse; body: DetailedActivity;  }> {
        const localVarPath = this.basePath + '/activities/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateActivityById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "UpdatableActivity")
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedActivity;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedActivity");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AthletesApiApiKeys {
}

export class AthletesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AthletesApiApiKeys, value: string) {
        (this.authentications as any)[AthletesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Returns the currently authenticated athlete.
     * @summary Get Authenticated Athlete
     */
    public getLoggedInAthlete () : Promise<{ response: http.ClientResponse; body: DetailedAthlete;  }> {
        const localVarPath = this.basePath + '/athlete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedAthlete;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedAthlete");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the the authenticated athlete's heart rate and power zones.
     * @summary Get Zones
     */
    public getLoggedInAthleteZones () : Promise<{ response: http.ClientResponse; body: Zones;  }> {
        const localVarPath = this.basePath + '/athlete/zones';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Zones;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Zones");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the activity stats of an athlete.
     * @summary Get Athlete Stats
     * @param id The identifier of the athlete.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getStats (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: ActivityStats;  }> {
        const localVarPath = this.basePath + '/athletes/{id}/stats'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getStats.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivityStats;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivityStats");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update the currently authenticated athlete.
     * @summary Update Athlete
     * @param body The athlete entity to update.
     */
    public updateLoggedInAthlete (body: DetailedAthlete) : Promise<{ response: http.ClientResponse; body: DetailedAthlete;  }> {
        const localVarPath = this.basePath + '/athlete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateLoggedInAthlete.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "DetailedAthlete")
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedAthlete;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedAthlete");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ClubsApiApiKeys {
}

export class ClubsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ClubsApiApiKeys, value: string) {
        (this.authentications as any)[ClubsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Enhanced Privacy Mode is respected for all activities.
     * @summary List Club Activities
     * @param id The identifier of the club.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getClubActivitiesById (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<SummaryActivity>;  }> {
        const localVarPath = this.basePath + '/clubs/{id}/activities'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getClubActivitiesById.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SummaryActivity>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SummaryActivity>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of the administrators of a given club.
     * @summary List Club Administrators.
     * @param id The identifier of the club.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getClubAdminsById (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<SummaryAthlete>;  }> {
        const localVarPath = this.basePath + '/clubs/{id}/admins'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getClubAdminsById.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SummaryAthlete>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SummaryAthlete>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a given club using its identifier.
     * @summary Get Club
     * @param id The identifier of the club.
     */
    public getClubById (id: number) : Promise<{ response: http.ClientResponse; body: DetailedClub;  }> {
        const localVarPath = this.basePath + '/clubs/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getClubById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedClub;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedClub");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of the athletes who are members of a given club.
     * @summary List Club Members
     * @param id The identifier of the club.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getClubMembersById (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<SummaryAthlete>;  }> {
        const localVarPath = this.basePath + '/clubs/{id}/members'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getClubMembersById.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SummaryAthlete>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SummaryAthlete>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of the clubs whose membership includes the authenticated athlete.
     * @summary List Athlete Clubs
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getLoggedInAthleteClubs (page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<SummaryClub>;  }> {
        const localVarPath = this.basePath + '/athlete/clubs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SummaryClub>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SummaryClub>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Adds the authenticated athlete to the club's membership.
     * @summary Join Club
     * @param id The identifier of the club.
     */
    public joinClubById (id: number) : Promise<{ response: http.ClientResponse; body: MembershipApplication;  }> {
        const localVarPath = this.basePath + '/clubs/{id}/join'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling joinClubById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MembershipApplication;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MembershipApplication");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Removes the authenticated athlete from the club's membership.
     * @summary Leave Club
     * @param id The identifier of the club.
     */
    public leaveClubById (id: number) : Promise<{ response: http.ClientResponse; body: MembershipApplication;  }> {
        const localVarPath = this.basePath + '/clubs/{id}/leave'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling leaveClubById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MembershipApplication;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MembershipApplication");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GearsApiApiKeys {
}

export class GearsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GearsApiApiKeys, value: string) {
        (this.authentications as any)[GearsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Returns an equipment using its identifier.
     * @summary Get Equipment
     * @param id The identifier of the gear.
     */
    public getGearById (id: number) : Promise<{ response: http.ClientResponse; body: DetailedGear;  }> {
        const localVarPath = this.basePath + '/gear/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getGearById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedGear;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedGear");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RoutesApiApiKeys {
}

export class RoutesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RoutesApiApiKeys, value: string) {
        (this.authentications as any)[RoutesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Returns a route using its identifier.
     * @summary Get Route
     * @param id The identifier of the route.
     */
    public getRouteById (id: number) : Promise<{ response: http.ClientResponse; body: Route;  }> {
        const localVarPath = this.basePath + '/routes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRouteById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Route;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Route");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list of the routes created by the authenticated athlete using their athlete ID.
     * @summary List Athlete Routes
     * @param id The identifier of the athlete.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getRoutesByAthleteId (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<Route>;  }> {
        const localVarPath = this.basePath + '/athletes/{id}/routes'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRoutesByAthleteId.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<Route>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<Route>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RunningRacesApiApiKeys {
}

export class RunningRacesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RunningRacesApiApiKeys, value: string) {
        (this.authentications as any)[RunningRacesApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Returns a running race for a given identifier.
     * @summary Get Running Race
     * @param id The identifier of the running race.
     */
    public getRunningRaceById (id: number) : Promise<{ response: http.ClientResponse; body: RunningRace;  }> {
        const localVarPath = this.basePath + '/running_races/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRunningRaceById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RunningRace;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RunningRace");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a list running races based on a set of search criteria.
     * @summary List Running Races
     * @param year Filters the list by a given year.
     */
    public getRunningRaces (year?: number) : Promise<{ response: http.ClientResponse; body: Array<RunningRace>;  }> {
        const localVarPath = this.basePath + '/running_races';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (year !== undefined) {
            localVarQueryParameters['year'] = ObjectSerializer.serialize(year, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<RunningRace>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RunningRace>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SegmentEffortsApiApiKeys {
}

export class SegmentEffortsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SegmentEffortsApiApiKeys, value: string) {
        (this.authentications as any)[SegmentEffortsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Returns a set of the authenticated athlete's segment efforts for a given segment.
     * @summary List Segment Efforts
     * @param id The identifier of the segment.
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getEffortsBySegmentId (id: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<DetailedSegmentEffort>;  }> {
        const localVarPath = this.basePath + '/segments/{id}/all_efforts'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getEffortsBySegmentId.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<DetailedSegmentEffort>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DetailedSegmentEffort>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a segment effort from an activity that is owned by the authenticated athlete.
     * @summary Get Segment Effort
     * @param id The identifier of the segment effort.
     */
    public getSegmentEffortById (id: number) : Promise<{ response: http.ClientResponse; body: DetailedSegmentEffort;  }> {
        const localVarPath = this.basePath + '/segment_efforts/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSegmentEffortById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedSegmentEffort;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedSegmentEffort");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SegmentsApiApiKeys {
}

export class SegmentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SegmentsApiApiKeys, value: string) {
        (this.authentications as any)[SegmentsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Returns the top 10 segments matching a specified query.
     * @summary Explore segments
     * @param bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
     * @param activityType Desired activity type.
     * @param minCat The minimum climbing category.
     * @param maxCat The maximum climbing category.
     */
    public exploreSegments (bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number) : Promise<{ response: http.ClientResponse; body: ExplorerResponse;  }> {
        const localVarPath = this.basePath + '/segments/explore';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bounds' is not null or undefined
        if (bounds === null || bounds === undefined) {
            throw new Error('Required parameter bounds was null or undefined when calling exploreSegments.');
        }

        if (bounds !== undefined) {
            localVarQueryParameters['bounds'] = ObjectSerializer.serialize(bounds, "Array<number>");
        }

        if (activityType !== undefined) {
            localVarQueryParameters['activity_type'] = ObjectSerializer.serialize(activityType, "'running' | 'riding'");
        }

        if (minCat !== undefined) {
            localVarQueryParameters['min_cat'] = ObjectSerializer.serialize(minCat, "number");
        }

        if (maxCat !== undefined) {
            localVarQueryParameters['max_cat'] = ObjectSerializer.serialize(maxCat, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ExplorerResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExplorerResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the specified segment leaderboard.
     * @summary Get Segment Leaderboard
     * @param id The identifier of the segment leaderboard.
     * @param gender Filter by gender.
     * @param ageGroup Premium Feature. Filter by age group.
     * @param weightClass Premium Feature. Filter by weight class.
     * @param following Filter by friends of the authenticated athlete.
     * @param clubId Filter by club.
     * @param dateRange Filter by date range.
     * @param contextEntries
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getLeaderboardBySegmentId (id: number, gender?: 'M' | 'F', ageGroup?: '0_19' | '20_24' | '25_34' | '35_44' | '45_54' | '55_64' | '65_69' | '70_74' | '75_plus', weightClass?: '0_124' | '125_149' | '150_164' | '165_179' | '180_199' | '200_224' | '225_249' | '250_plus' | '0_54' | '55_64' | '65_74' | '75_84' | '85_94' | '95_104' | '105_114' | '115_plus', following?: boolean, clubId?: number, dateRange?: 'this_year' | 'this_month' | 'this_week' | 'today', contextEntries?: number, page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: SegmentLeaderboard;  }> {
        const localVarPath = this.basePath + '/segments/{id}/leaderboard'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLeaderboardBySegmentId.');
        }

        if (gender !== undefined) {
            localVarQueryParameters['gender'] = ObjectSerializer.serialize(gender, "'M' | 'F'");
        }

        if (ageGroup !== undefined) {
            localVarQueryParameters['age_group'] = ObjectSerializer.serialize(ageGroup, "'0_19' | '20_24' | '25_34' | '35_44' | '45_54' | '55_64' | '65_69' | '70_74' | '75_plus'");
        }

        if (weightClass !== undefined) {
            localVarQueryParameters['weight_class'] = ObjectSerializer.serialize(weightClass, "'0_124' | '125_149' | '150_164' | '165_179' | '180_199' | '200_224' | '225_249' | '250_plus' | '0_54' | '55_64' | '65_74' | '75_84' | '85_94' | '95_104' | '105_114' | '115_plus'");
        }

        if (following !== undefined) {
            localVarQueryParameters['following'] = ObjectSerializer.serialize(following, "boolean");
        }

        if (clubId !== undefined) {
            localVarQueryParameters['club_id'] = ObjectSerializer.serialize(clubId, "number");
        }

        if (dateRange !== undefined) {
            localVarQueryParameters['date_range'] = ObjectSerializer.serialize(dateRange, "'this_year' | 'this_month' | 'this_week' | 'today'");
        }

        if (contextEntries !== undefined) {
            localVarQueryParameters['context_entries'] = ObjectSerializer.serialize(contextEntries, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SegmentLeaderboard;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SegmentLeaderboard");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * List of the authenticated athlete's starred segments.
     * @summary List Starred Segments
     * @param page Page number.
     * @param perPage Number of items per page. Defaults to 30.
     */
    public getLoggedInAthleteStarredSegments (page?: number, perPage?: number) : Promise<{ response: http.ClientResponse; body: Array<SummarySegment>;  }> {
        const localVarPath = this.basePath + '/segments/starred';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (perPage !== undefined) {
            localVarQueryParameters['per_page'] = ObjectSerializer.serialize(perPage, "number");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<SummarySegment>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SummarySegment>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the specified segment.
     * @summary Get Segment
     * @param id The identifier of the segment.
     */
    public getSegmentById (id: number) : Promise<{ response: http.ClientResponse; body: DetailedSegment;  }> {
        const localVarPath = this.basePath + '/segments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSegmentById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Stars/Unstars the given segment for the authenticated athlete.
     * @summary Star Segment
     * @param id The identifier of the segment to star.
     * @param starred If true, star the segment; if false, unstar the segment.
     */
    public starSegment (id: number, starred: boolean) : Promise<{ response: http.ClientResponse; body: DetailedSegment;  }> {
        const localVarPath = this.basePath + '/segments/{id}/starred'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling starSegment.');
        }

        // verify required parameter 'starred' is not null or undefined
        if (starred === null || starred === undefined) {
            throw new Error('Required parameter starred was null or undefined when calling starSegment.');
        }


        let localVarUseFormData = false;

        if (starred !== undefined) {
            localVarFormParams['starred'] = ObjectSerializer.serialize(starred, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DetailedSegment;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DetailedSegment");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum StreamsApiApiKeys {
}

export class StreamsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: StreamsApiApiKeys, value: string) {
        (this.authentications as any)[StreamsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Returns the given activity's streams.
     * @summary Get Activity Streams
     * @param id The identifier of the activity.
     * @param keys Desired stream types.
     * @param keyByType Must be true.
     */
    public getActivityStreams (id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean) : Promise<{ response: http.ClientResponse; body: StreamSet;  }> {
        const localVarPath = this.basePath + '/activities/{id}/streams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getActivityStreams.');
        }

        // verify required parameter 'keys' is not null or undefined
        if (keys === null || keys === undefined) {
            throw new Error('Required parameter keys was null or undefined when calling getActivityStreams.');
        }

        // verify required parameter 'keyByType' is not null or undefined
        if (keyByType === null || keyByType === undefined) {
            throw new Error('Required parameter keyByType was null or undefined when calling getActivityStreams.');
        }

        if (keys !== undefined) {
            localVarQueryParameters['keys'] = ObjectSerializer.serialize(keys, "Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>");
        }

        if (keyByType !== undefined) {
            localVarQueryParameters['key_by_type'] = ObjectSerializer.serialize(keyByType, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns a set of streams for a segment effort completed by the authenticated athlete.
     * @summary Get segment effort streams
     * @param id The identifier of the segment effort.
     * @param keys The types of streams to return.
     * @param keyByType Must be true.
     */
    public getSegmentEffortStreams (id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean) : Promise<{ response: http.ClientResponse; body: StreamSet;  }> {
        const localVarPath = this.basePath + '/segment_efforts/{id}/streams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSegmentEffortStreams.');
        }

        // verify required parameter 'keys' is not null or undefined
        if (keys === null || keys === undefined) {
            throw new Error('Required parameter keys was null or undefined when calling getSegmentEffortStreams.');
        }

        // verify required parameter 'keyByType' is not null or undefined
        if (keyByType === null || keyByType === undefined) {
            throw new Error('Required parameter keyByType was null or undefined when calling getSegmentEffortStreams.');
        }

        if (keys !== undefined) {
            localVarQueryParameters['keys'] = ObjectSerializer.serialize(keys, "Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>");
        }

        if (keyByType !== undefined) {
            localVarQueryParameters['key_by_type'] = ObjectSerializer.serialize(keyByType, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns the given segment's streams.
     * @summary Get Segment Streams
     * @param id The identifier of the segment.
     * @param keys The types of streams to return.
     * @param keyByType Must be true.
     */
    public getSegmentStreams (id: number, keys: Array<'distance' | 'latlng' | 'altitude'>, keyByType: boolean) : Promise<{ response: http.ClientResponse; body: StreamSet;  }> {
        const localVarPath = this.basePath + '/segments/{id}/streams'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSegmentStreams.');
        }

        // verify required parameter 'keys' is not null or undefined
        if (keys === null || keys === undefined) {
            throw new Error('Required parameter keys was null or undefined when calling getSegmentStreams.');
        }

        // verify required parameter 'keyByType' is not null or undefined
        if (keyByType === null || keyByType === undefined) {
            throw new Error('Required parameter keyByType was null or undefined when calling getSegmentStreams.');
        }

        if (keys !== undefined) {
            localVarQueryParameters['keys'] = ObjectSerializer.serialize(keys, "Array<'distance' | 'latlng' | 'altitude'>");
        }

        if (keyByType !== undefined) {
            localVarQueryParameters['key_by_type'] = ObjectSerializer.serialize(keyByType, "boolean");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: StreamSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "StreamSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UploadsApiApiKeys {
}

export class UploadsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'strava_oauth': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UploadsApiApiKeys, value: string) {
        (this.authentications as any)[UploadsApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.strava_oauth.accessToken = token;
    }
    /**
     * Uploads a new data file to create an activity from.
     * @summary Upload Activity
     * @param file The uploaded file.
     * @param name The desired name of the resulting activity.
     * @param description The desired description of the resulting activity.
     * @param _private Whether the resulting activity should be private.
     * @param trainer Whether the resulting activity should be marked as having been performed on a trainer.
     * @param commute Whether the resulting activity should be tagged as a commute.
     * @param dataType The format of the uploaded file.
     * @param externalId The desired external identifier of the resulting activity.
     */
    public createUpload (file?: Buffer, name?: string, description?: string, _private?: number, trainer?: string, commute?: string, dataType?: 'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz', externalId?: string) : Promise<{ response: http.ClientResponse; body: Upload;  }> {
        const localVarPath = this.basePath + '/uploads';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};


        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (_private !== undefined) {
            localVarFormParams['private'] = ObjectSerializer.serialize(_private, "number");
        }

        if (trainer !== undefined) {
            localVarFormParams['trainer'] = ObjectSerializer.serialize(trainer, "string");
        }

        if (commute !== undefined) {
            localVarFormParams['commute'] = ObjectSerializer.serialize(commute, "string");
        }

        if (dataType !== undefined) {
            localVarFormParams['data_type'] = ObjectSerializer.serialize(dataType, "'fit' | 'fit.gz' | 'tcx' | 'tcx.gz' | 'gpx' | 'gpx.gz'");
        }

        if (externalId !== undefined) {
            localVarFormParams['external_id'] = ObjectSerializer.serialize(externalId, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Upload;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Upload");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns an upload for a given identifier.
     * @summary Get Upload
     * @param uploadId The identifier of the upload.
     */
    public getUploadById (uploadId: number) : Promise<{ response: http.ClientResponse; body: Upload;  }> {
        const localVarPath = this.basePath + '/uploads/{uploadId}'
            .replace('{' + 'uploadId' + '}', encodeURIComponent(String(uploadId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'uploadId' is not null or undefined
        if (uploadId === null || uploadId === undefined) {
            throw new Error('Required parameter uploadId was null or undefined when calling getUploadById.');
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.strava_oauth.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Upload;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Upload");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
